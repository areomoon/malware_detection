import os
import numpy as np
import pandas as pd
import torch
from tqdm import tqdm
import torch.nn as nn
import argparse
from model.Malware_CNN import MalCNNnet_feature
from utils.dataloader import MalwareTestDataset
from torch.utils.data import DataLoader

def reduce_mem_usage(df, verbose=True):
    numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']
    start_mem = df.memory_usage().sum() / 1024 ** 2
    for col in df.columns:
        col_type = df[col].dtypes
        if col_type in numerics:
            c_min = df[col].min()
            c_max = df[col].max()
            if str(col_type)[:3] == 'int':
                if c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:
                    df[col] = df[col].astype(np.int16)
                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:
                    df[col] = df[col].astype(np.int32)
                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:
                    df[col] = df[col].astype(np.int64)
            else:
                if c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:
                    df[col] = df[col].astype(np.float32)
                else:
                    df[col] = df[col].astype(np.float64)
    end_mem = df.memory_usage().sum() / 1024 ** 2
    if verbose: print('Mem. usage decreased to {:5.2f} Mb ({:.1f}% reduction)'.format(end_mem, 100 * (
                start_mem - end_mem) / start_mem))
    return df

def to_np(t):
    return t.cpu().detach().numpy()

def str2bool(v):
    return v.lower() in ("yes", "true", "t", "1")

def save_model(dir_name, model, idx):
    print("MalCNNmodel_{}.model".format(idx))
    save_state_path = os.path.join(dir_name, 'MalCNNmodel_'+ idx +'_dict.pkl')
    torch.save(model.state_dict(), save_state_path)
    print("Chekcpoint saved")

def load_model(dict_name, model, idx):
    save_state_path = os.path.join(dict_name, 'MalCNNmodel_'+ idx +'_dict.pkl')
    state = torch.load(save_state_path)
    model.load_state_dict(state)
    print("Chekcpoint Loaded")

def valid(model,valid_loader,device):
    model.eval()
    test_correct= 0.0
    for batch_idx, (image, tag) in enumerate(valid_loader):
        image = image.to(device)
        tags = tags.to(device)
        outputs = model(image)
        predict_vector = np.argmax(to_np(outputs), axis=1)
        label_vector = np.argmax(to_np(tags), axis=1)
        bool_vector = predict_vector == label_vector
        test_correct += bool_vector.sum()
    accuracy = test_correct / len(valid_loader)
    print('Valiadation set Acc {:2.4f}'.format(accuracy))
    return accuracy

parser = argparse.ArgumentParser(description='CNN feature extraction Malware Detection With Pytorch')

train_set = parser.add_mutually_exclusive_group()
parser.add_argument('--dataset', default='test_image', type=str,
                    help='Dataset directory path')
parser.add_argument('--submission_path', default='../ResultSample.csv', type=str,
                    help='Sample submission csv file path')
parser.add_argument('--pretrained_weights', default=None, type=str,
                    help='Pretrained model Idx, Input Example: epoch14')
parser.add_argument('--model_save_dir',default='model/weights', type=str,
                    help='Trained Model State Dict Saved Path')
parser.add_argument('--batch_size', default=1, type=int,
                    help='Batch size for training')
parser.add_argument('--num_workers', default=0, type=int,
                    help='Number of workers used in dataloading')
parser.add_argument('--cuda', default=True, type=str2bool,
                    help='Use CUDA to train model')
parser.add_argument('--num_of_class', default=10, type=int,
                    help='Number of classes to predict')
parser.add_argument('--mode', default='eval',
                    help='Choose Train or Eval mode')
args = parser.parse_args()

if torch.cuda.is_available():
    if args.cuda:
        torch.set_default_tensor_type('torch.cuda.FloatTensor')
    if not args.cuda:
        print("WARNING: It looks like you have a CUDA device, but aren't " +
              "using CUDA.\n Run with --cuda for optimal training speed.")
        torch.set_default_tensor_type('torch.FloatTensor')
else:
    torch.set_default_tensor_type('torch.FloatTensor')

# Load Neural Network Model
model = MalCNNnet_feature(num_of_classes= args.num_of_class)

if args.cuda:
    model= torch.nn.DataParallel(model)
    model.cuda()

# Load pretrained weights
try:
    load_model(args.model_save_dir, model, args.pretrained_weights)
except FileExistsError:
    print('Please specify the correct pretrained model weights path')


if torch.cuda.is_available() and torch.cuda.device_count() > 0:
    print("GPU device is available")
    device = torch.device('cuda')
    model.to(device)
else:
    device = torch.device('cpu')
    model.to(device)

print('Loading test dataset...')
print('Extract image feature via MalwareCNN net on: ', args.dataset)
print('Using the specified args:')
print(args)

eval_data = MalwareTestDataset(root_dir=args.dataset, csv_file=args.submission_path)
eval_loader = DataLoader(eval_data, batch_size=args.batch_size, num_workers=args.num_workers,shuffle=False)

# Create submission file
id_list = []
img_feature_array_list = []

if args.mode == 'eval':
    for batch_idx, (image,id) in enumerate(tqdm(eval_loader)):
        image = image.to(device)
        outputs = model(image)

        id_list.append(id[0])
        img_feature_array_list.append(to_np(outputs)[0])

print('Finish Prediciton')
print('Create submission file...')

pred_dict = {'md5':id_list, 'prediction':img_feature_array_list}
pre_submission = pd.DataFrame.from_dict(pred_dict)

image_feature_cols =  ['img_feature'+str(i) for i in range(500)]
prediction_df = pd.DataFrame(pre_submission.prediction.tolist(), columns=image_feature_cols)
submission = pd.concat([pre_submission, prediction_df], axis=1)
submission.drop(['prediction'], axis=1, inplace=True)
submission = reduce_mem_usage(submission)
submission.to_csv('image_features.csv',index=False)





